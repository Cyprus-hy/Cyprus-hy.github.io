<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[利用Faster RCNN实现对驾驶员的异常行为监测]]></title>
    <url>%2F2018%2F12%2F02%2FMonitor-The-Driver-By-Faster-RCNN%2F</url>
    <content type="text"><![CDATA[引言今年上半年的时候和小伙伴一起申了个国创项目，做的是用深度学习（神经网络）来检测驾驶员的异常行为。简单点说就是驾驶员在驾驶的时候可能会有抽烟、喝水、打电话等等违规行为，这些行为都在一定程度上降低了服务体验与安全风险，我们要做的就是及时监测这些异常行为并给出反馈。目前我们已经做到了对驾驶员打电话与喝水这两种异常行为以及正常驾驶的监测，用到的技术栈是Faster RCNN，这篇博客就是为了记录下具体的实现过程。 配置环境我们用的环境是GTX1060显卡+Ubuntu18.04系统+CUDAA8.0+CUDNN5.1.10+CAFFE。安装过程真的是一言难尽，反正我装的时候显卡驱动和CAFFE老是报各种错，后来都是小伙伴帮忙装上的，大家可以参考他的教程。 具体实现环境配好了（反正我自己是配不来，狗头）以后，就可以开始实现了，大致分成数据预处理、人脸识别、模型训练与测试这几部分，下面逐一介绍。 数据预处理我们的数据集主要是驾驶员在驾驶时的行为视频，老师给了一些，但很有限，所以我们又模拟驾驶环境自己拍了一些，首先把视频分割成一帧一帧的图像，代码如下（python xxx.py）： 123456789101112131415161718192021222324252627282930#!usr/bin/pythonimport os.pathimport cv2videos_src_path = "/home/yue/code/face-py-faster-rcnn/data/testvideo"pathDir = os.listdir(videos_src_path)a = 1for allDir in pathDir: videopath = os.path.join(videos_src_path,allDir) #print allDir vc = cv2.VideoCapture(videopath) c = 1 rval, frame = vc.read() timeF = 3 while rval: rval, frame = vc.read() if (c % timeF == 0 and rval): cv2.imwrite("/home/yue/code/face-py-faster-rcnn/data/testphoto/" + str(a) + '.jpg', frame) #image=cv2.imread(str(a)+'.jpg') #cv2.resize(image, (960, 660), interpolation=cv2.INTER_CUBIC) a = a + 1 c = c + 1 cv2.waitKey(1) vc.release() 为了模型训练的方便，我们再将图片重命名成VOC2007的格式，也就是六位数字： 12345678910111213import shutilimport osimport globif __name__ == '__main__': cur_dir = os.getcwd() dest = os.path.join(cur_dir, "PicsTxt", "driver.txt") src = os.path.join(cur_dir, "OrignalPics") imgs = glob.glob(os.path.join(src, "*.jpg")) for index, item in enumerate(imgs): os.rename(item, os.path.join(src, "%06d.jpg" % index)) 接着把所有图片名写入driver.txt文档中： 123456789101112131415import shutilimport osimport globif __name__ == '__main__': cur_dir = os.getcwd() dest = os.path.join(cur_dir, "PicsTxt", "driver.txt") src = os.path.join(cur_dir, "OrignalPics") imgs = glob.glob(os.path.join(src, "*.jpg")) with open(dest, "w+") as f: for index, item in enumerate(imgs): (_, tempfilename) = os.path.split(item) (filename, _) = os.path.splitext(tempfilename) f.write(filename + '\n') 驾驶员人脸检测传统意义上的目标分类问题都是先把数据集的目标框出来再打标签（label），这样费时费力，所以我们做了一个改进就是先通过人脸识别网络(face-py-faster-rcnn)将人脸识别出来再手动打上标签，因为驾驶员的异常行为大多发生在脸部周围嘛，实际操作的时候只需要将人脸框图适当放大即可。跑一下人脸识别网络：python tools/get_face.py —gpu=0，然后将生成的人脸信息写入txt文件（face、框的坐标等）。这里贴一下get_face的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213from __future__ import divisionimport _init_pathsfrom fast_rcnn.config import cfgfrom fast_rcnn.test import im_detectfrom fast_rcnn.nms_wrapper import nmsfrom utils.timer import Timerimport matplotlib.pyplot as pltimport numpy as npimport scipy.io as sioimport caffe, os, sys, cv2import argparseimport sysimport mathNETS = &#123;'vgg16': ('VGG16', 'output/faster_rcnn_end2end/train/vgg16_faster_rcnn_iter_80000.caffemodel')&#125;def get_imdb_fddb(data_dir): # input images imdb = [] ''' nfold = 10 for n in xrange(nfold): file_name = 'FDDB-folds/FDDB-fold-%02d.txt' % (n + 1) file_name = os.path.join(data_dir, file_name) fid = open(file_name, 'r') image_names = [] for im_name in fid: image_names.append(im_name.strip('\n')) imdb.append(image_names) ''' file_name = 'PicsTxt/driver.txt' file_name = os.path.join(data_dir, file_name) fid = open(file_name, 'r') image_names = [] for im_name in fid: image_names.append(im_name.strip('\n')) imdb.append(image_names) return imdbdef vis_detections(im, class_name, dets, thresh=0.5): """Draw detected bounding boxes.""" inds = np.where(dets[:, -1] &gt;= thresh)[0] if len(inds) == 0: return im = im[:, :, (2, 1, 0)] fig, ax = plt.subplots(figsize=(12, 12)) ax.imshow(im, aspect='equal') for i in inds: bbox = dets[i, :4] score = dets[i, -1] ax.add_patch( plt.Rectangle((bbox[0], bbox[1]), bbox[2] - bbox[0], bbox[3] - bbox[1], fill=False, edgecolor='red', linewidth=3.5) ) ax.text(bbox[0], bbox[1] - 2, '&#123;:s&#125; &#123;:.3f&#125;'.format(class_name, score), bbox=dict(facecolor='blue', alpha=0.5), fontsize=14, color='white') ax.set_title(('&#123;&#125; detections with ' 'p(&#123;&#125; | box) &gt;= &#123;:.1f&#125;').format(class_name, class_name, thresh), fontsize=14) plt.axis('off') plt.tight_layout() plt.draw() # plt.show()def parse_args(): """Parse input arguments.""" parser = argparse.ArgumentParser(description='Face Detection using Faster R-CNN') parser.add_argument('--gpu', dest='gpu_id', help='GPU device id to use [0]', default=0, type=int) parser.add_argument('--cpu', dest='cpu_mode', help='Use CPU mode (overrides --gpu)', action='store_true') parser.add_argument('--net', dest='demo_net', help='Network to use [vgg16]', choices=NETS.keys(), default='vgg16') args = parser.parse_args() return argsdef obtain_face(): cfg.TEST.HAS_RPN = True # Use RPN for proposals # cfg.TEST.BBOX_REG = False args = parse_args() prototxt = os.path.join(cfg.MODELS_DIR, NETS[args.demo_net][0], 'faster_rcnn_alt_opt', 'faster_rcnn_test.pt') caffemodel = os.path.join(cfg.DATA_DIR, 'faster_rcnn_models', NETS[args.demo_net][1]) prototxt = 'models/face/VGG16/faster_rcnn_end2end/test.prototxt' caffemodel = NETS[args.demo_net][1] if not os.path.isfile(caffemodel): raise IOError(('&#123;:s&#125; not found.\nDid you run ./data/script/' 'fetch_faster_rcnn_models.sh?').format(caffemodel)) if args.cpu_mode: caffe.set_mode_cpu() else: caffe.set_mode_gpu() caffe.set_device(args.gpu_id) cfg.GPU_ID = args.gpu_id net = caffe.Net(prototxt, caffemodel, caffe.TEST) print('\n\nLoaded network &#123;:s&#125;'.format(caffemodel)) data_dir = 'data/Driver/' out_dir = 'output/Result/res_txt/' if not os.path.exists(out_dir): os.makedirs(out_dir) CONF_THRESH = 0.65 NMS_THRESH = 0.15 imdb = get_imdb_fddb(data_dir) # Warmup on a dummy image im = 128 * np.ones((300, 500, 3), dtype=np.uint8) for i in xrange(2): _, _ = im_detect(net, im) nfold = len(imdb) for i in xrange(nfold): image_names = imdb[i] # detection file # dets_file_name = os.path.join(out_dir, 'FDDB-test-res.txt') # fid = open(dets_file_name, 'w') # sys.stdout.write('%s ' % (i + 1)) for idx, im_name in enumerate(image_names): # timer = Timer() # timer.tic() dets_file_name = os.path.join(out_dir, '%s.txt' % im_name) fid = open(dets_file_name, 'w') # Load the demo image mat_name = im_name + '.mat' # im_path = im_name + '.jpg' im = cv2.imread(os.path.join(data_dir, 'OrignalPics', im_name + '.jpg')) # # Detect all object classes and regress object bounds # timer = Timer() # timer.tic() scores, boxes = im_detect(net, im) # timer.toc() # print ('Detection took &#123;:.3f&#125;s for ' # '&#123;:d&#125; object proposals').format(timer.total_time, boxes.shape[0]) cls_ind = 1 cls_boxes = boxes[:, 4 * cls_ind:4 * (cls_ind + 1)] cls_scores = scores[:, cls_ind] dets = np.hstack((cls_boxes, cls_scores[:, np.newaxis])).astype(np.float32) keep = nms(dets, NMS_THRESH) dets = dets[keep, :] keep = np.where(dets[:, 4] &gt; CONF_THRESH) dets = dets[keep] # vis_detections(im, 'face', dets, CONF_THRESH) # dets[:, 2] = dets[:, 2] - dets[:, 0] + 1 # dets[:, 3] = dets[:, 3] - dets[:, 1] + 1 # timer.toc() # print ('Detection took &#123;:.3f&#125;s for ' # '&#123;:d&#125; object proposals').format(timer.total_time, boxes.shape[0]) # fid.write(im_name + '\n') # fid.write(str(dets.shape[0]) + '\n') cls = 'face' shape = im.shape h = shape[0] w = shape[1] for j in xrange(dets.shape[0]): fid.write('%d %d %d %d %s\n' % ( round(dets[j, 0]-w/20), round(dets[j, 1]-h/30), round(dets[j, 2]+w/20), round(dets[j, 3]+h/20), cls)) ''' if ((idx + 1) % 10) == 0: sys.stdout.write('%.3f ' % ((idx + 1) / len(image_names) * 100)) sys.stdout.flush() ''' # print # '' fid.close()if __name__ == '__main__': obtain_face() # os.system('cp ./fddb_res/*.txt ~/Code/FDDB/results') 由于生成的框图坐标需要用XML的格式存储，所以我们转一下格式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#! /usr/bin/python# -*- coding:UTF-8 -*-import os, sysimport globfrom PIL import Image# 图像存储位置src_img_dir = "/home/yue/code/face-py-faster-rcnn/data/Driver/OrignalPics"# 图像的 ground truth 的 txt 文件存放位置src_txt_dir = "/home/yue/code/face-py-faster-rcnn/output/Result/res_txt"src_xml_dir = "/home/yue/code/face-py-faster-rcnn/output/Result/res_xml"img_Lists = glob.glob(src_img_dir + '/*.jpg')img_basenames = [] # e.g. 100.jpgfor item in img_Lists: img_basenames.append(os.path.basename(item))img_names = [] # e.g. 100for item in img_basenames: temp1, temp2 = os.path.splitext(item) img_names.append(temp1)for img in img_names: im = Image.open((src_img_dir + '/' + img + '.jpg')) width, height = im.size # open the crospronding txt file gt = open(src_txt_dir + '/' + img + '.txt').read().splitlines() #gt = open(src_txt_dir + '/gt_' + img + '.txt').read().splitlines() # write in xml file #os.mknod(src_xml_dir + '/' + img + '.xml') xml_file = open((src_xml_dir + '/' + img + '.xml'), 'w') xml_file.write('&lt;annotation&gt;\n') xml_file.write(' &lt;folder&gt;Driver&lt;/folder&gt;\n') xml_file.write(' &lt;filename&gt;' + str(img) + '.jpg' + '&lt;/filename&gt;\n') xml_file.write(' &lt;size&gt;\n') xml_file.write(' &lt;width&gt;' + str(width) + '&lt;/width&gt;\n') xml_file.write(' &lt;height&gt;' + str(height) + '&lt;/height&gt;\n') xml_file.write(' &lt;depth&gt;3&lt;/depth&gt;\n') xml_file.write(' &lt;/size&gt;\n') # write the region of image on xml file for img_each_label in gt: spt = img_each_label.split(' ') #这里如果txt里面是以逗号‘，’隔开的，那么就改为spt = img_each_label.split(',')。 xml_file.write(' &lt;object&gt;\n') xml_file.write(' &lt;name&gt;' + str(spt[4]) + '&lt;/name&gt;\n') xml_file.write(' &lt;pose&gt;Unspecified&lt;/pose&gt;\n') xml_file.write(' &lt;truncated&gt;0&lt;/truncated&gt;\n') xml_file.write(' &lt;difficult&gt;0&lt;/difficult&gt;\n') xml_file.write(' &lt;bndbox&gt;\n') xml_file.write(' &lt;xmin&gt;' + str(spt[0]) + '&lt;/xmin&gt;\n') xml_file.write(' &lt;ymin&gt;' + str(spt[1]) + '&lt;/ymin&gt;\n') xml_file.write(' &lt;xmax&gt;' + str(spt[2]) + '&lt;/xmax&gt;\n') xml_file.write(' &lt;ymax&gt;' + str(spt[3]) + '&lt;/ymax&gt;\n') xml_file.write(' &lt;/bndbox&gt;\n') xml_file.write(' &lt;/object&gt;\n') xml_file.write('&lt;/annotation&gt;') 可以看一下实际生成的XML文件： 最后自然就是给数据集打上标签了（还是挺烦的orz）。 模型训练与测试到这里所有的准备工作已经完成了，接下来就是跑py-faster-rcnn了，大致分为以下几个步骤： 训练图片放JPEGImages文件夹，xml放Annotations文件夹 ImageSets\Main放四个txt文件，里面是分割的训练验证集与测试集（图片名，不含.jpg），参考这个 copy下py-faster-rcnn，对代码一些地方做修改，主要是分类的类别数（参考网址） 训练报assert（boxes[:,2]&gt;=boxes[:,0]）.all()的错可以参考这个 用zf训练模型（./experiments/scripts/faster_rcnn_alt_opt.sh 0 ZF pascal_voc） 测试模型：把要测试的视频分割成图片，修改一下tools/demo.py里的图片地址以及图片张数 把测试后保存的图片重新合成视频 结语目前做的东西大致就是这么多啦，考完试后还会和小伙伴就目标追踪算法、司机身份识别等做一些优化。]]></content>
      <categories>
        <category>Faster RCNN实操</category>
      </categories>
      <tags>
        <tag>Faster RCNN</tag>
        <tag>人脸检测</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#前端开发之Get与Post方法]]></title>
    <url>%2F2018%2F11%2F05%2FThe-Post-And-Get-Method-of-C%2F</url>
    <content type="text"><![CDATA[引入程序实践课的大作业老师让我们用C#写前端，PHP写后端做一个窗体应用程序，然后我和室友就一起做了个体育赛事的报名系统。其中我负责的是前端，这里就简单记录一下C#的Get与Post方法。 首先简单介绍一下，HTTP定义了许多与服务器交互的方法，包括Put、Delete、Get与Post，分别对应增、删、查、改操作。但其中用的最多的就是Post与Get：通常来说，Post多用于更新数据而Get多用于请求数据，且它两都是通过Url进行数据传输的。 Get方法首先我们定义如下的HttpGet函数： 1234567891011121314public string HttpGet(string Url, string postDataStr)&#123; HttpWebRequest request = (HttpWebRequest)WebRequest.Create(Url + (postDataStr == &quot;&quot; ? &quot;&quot; : &quot;?&quot;) + postDataStr); request.Method = &quot;GET&quot;; request.ContentType = &quot;text/html;charset=UTF-8&quot;; HttpWebResponse response = (HttpWebResponse)request.GetResponse(); Stream myResponseStream = response.GetResponseStream(); StreamReader myStreamReader = new StreamReader(myResponseStream, Encoding.GetEncoding(&quot;utf-8&quot;)); string retString = myStreamReader.ReadToEnd(); myStreamReader.Close(); myResponseStream.Close(); return retString;&#125; 以我编写的从数据库请求用户的个人信息数据为例，我们可以进行如下调用： 12345// 获取个人信息，Common.Login_ID是用户的账号，封装成了共享数据类string URL = &quot;http://localhost/cxsj_final_project-master/Home/User/getInfoByUserID/&quot; + Common.Login_ID;string content = HttpGet(URL, &quot;&quot;);//User是封装的用户信息类，数据以json格式进行传输User resultobj = JsonConvert.DeserializeObject&lt;User&gt;(content); Post方法首先我们定义如下的HttpPost函数： 123456789101112131415161718192021private string HttpPost(string Url, string postDataStr)&#123; HttpWebRequest request = (HttpWebRequest)WebRequest.Create(Url); request.Method = &quot;POST&quot;; request.ContentType = &quot;application/x-www-form-urlencoded&quot;; request.ContentLength = Encoding.UTF8.GetByteCount(postDataStr); Stream myRequestStream = request.GetRequestStream(); StreamWriter myStreamWriter = new StreamWriter(myRequestStream, Encoding.GetEncoding(&quot;gb2312&quot;)); myStreamWriter.Write(postDataStr); myStreamWriter.Close(); HttpWebResponse response = (HttpWebResponse)request.GetResponse(); Stream myResponseStream = response.GetResponseStream(); StreamReader myStreamReader = new StreamReader(myResponseStream, Encoding.GetEncoding(&quot;utf-8&quot;)); string retString = myStreamReader.ReadToEnd(); myStreamReader.Close(); myResponseStream.Close(); return retString;&#125; 以我编写的用户登录判断为例，我们可以进行如下调用： 12345678910111213//用户输入账号与密码信息int userID = Convert.ToInt32(inputUser_id.Text);string password = Convert.ToString(inputPwd.Text);//LoginUser是封装的用户登录时的信息类LoginUser newobj = new LoginUser(userID, password);//本地Urlstring PostURL = &quot;http://localhost/cxsj_final_project-master/Home/Log/postLogin&quot;;//转化成json串格式string jsonContent = JsonConvert.SerializeObject(newobj);string Param = &quot;Content=&quot; + jsonContent;//进行Post请求，返回值为是否是管理员以及是否登录成功string result = HttpPost(PostURL, Param);IsLogin resultobj = JsonConvert.DeserializeObject&lt;IsLogin&gt;(result); 总结最近比较忙，就不太想打啥字了，基本意思都表达了，具体的源代码可以看这里。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>C#</tag>
        <tag>Post</tag>
        <tag>Get</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之回归决策树]]></title>
    <url>%2F2018%2F10%2F24%2FThe-DesionTreeRegressor-of-Machine-Learning%2F</url>
    <content type="text"><![CDATA[引入大三上的课真的好多啊，而且专业课难度都不小，各种课程实验、大作业让人头秃，每周末还得去去实验室。感觉最近的压力有点大，还是慢慢来吧，放松心态，just do it! 之前上机器学习课有一个作业就是关于回归树的，所以在这里写篇博客记录一下。 书上和网上所提到的决策树大多都是用来分类的，简单地说就是先进行特征选择，用到的方法主要包括信息增益、增益率与基尼指数；然后再生成决策树；最后为了防止过拟合再进行一个剪枝，可以是预剪枝，也可以是后剪枝。一般来说，用于分类的数据都要求是离散的，如果出现连续变量的话可以进行一个二分。 那么回归树的话，顾名思义，预测的标签就是一个连续值。它的核心思想就在于将整个输入空间划分为多个区域，然后用每个区域的“均值”作为该空间的预测输出。同时，它是采用平方误差最小化的准则进行特征选择的，而且回归树一定是二叉树。 生成回归树回归树的生成主要有以下几个步骤： 首先选择最优切分变量j与对应的分割点s（切分变量j就是某个特征），使得下式达到最小值： \mathop{min}_{j,s}\mathop{\sum}_{x_i\in R_1(j,s)}(y_i-c_1)^2+min\mathop{\sum}_{x_i\in R_2(j,s)}(y_i-c_2)^2这公式咋一看很吓人，但其实理解起来很简单。就是先遍历数据的每一个特征j，对每一个特征j再遍历所有可能的分割点s，使得预测标签与实际标签的平方误差和达到最小。其中$R_m$是被划分的输入空间；$c_m$是空间$R_m$对应的固定输出值。 然后利用选定的特征变量j与分割点s划分输入空间并决定各个区域内的输出值：即$R_1$是特征值小于等于分割点s的样本点组成的区域，$R_2$是特征值大于s的样本点组成的区域；而为了使每个区域内的平方差之和最小，显然$c_m$应等于空间$R_m$中各样本点y值的均值。 接着再不断地对两个子区域执行以上操作，并利用拟合训练集数据得到的残差进行更新，直到回归树模型满足误差条件。 最后，回归树将输入空间划分为n个区域，并得到每个区域下的固定输出值。当我们要利用训练好的回归树对测试集数据进行验证时，只需判定测试集数据所处的空间区域$R_m$，而其中的固定输出值$c_m$即为预测结果。 实例分析如果觉得上面的算法有些复杂，那么接下来我们再看一个实例分析，便于理解。例如我们要对以下数据集训练回归树： $x_i$ 1 2 3 4 5 6 7 8 9 10 $y_i$ 5.56 5.70 5.91 6.40 6.80 7.05 8.90 8.70 9.00 9.05 由于这里只有一个特征，因此j是固定了的，我们再假设分割点s的所有可能取值为(1.5,2.5,3.5…9.5)，对于每一个取值，我们都可以得到相应的划分空间$R_1$与$R_2$，以及对应空间下的输出值$c_m$，也就是空间内所有样本标签的均值。接下来我们进行遍历，计算不同s值下平方误差和，并以误差和最小时的s值作为输入空间的划分。由此，最初的回归树就形成了：即当数据在输入空间$R_1$时输出为$c_1$，在输入空间$R_2$时输出为$c_2$。在此基础上，我们对训练集数据进行拟合，并利用残差不断更新回归树，直到预测误差满足条件。 对于更具体地求解过程，可以参考这篇博客。 代码实现由于我比较懒，因此我就直接用了sklearn库的回归树模型，数据集是datasets自带的波士顿房价数据集。然后我还用pydotplus绘图模块把回归树画了出来，关于pydotplus的安装，可以参考这篇教程。代码如下： 12345678910111213141516171819202122232425262728293031323334from sklearn.model_selection import train_test_splitfrom sklearn.tree import DecisionTreeRegressor # 导入决策回归树的模型from sklearn.datasets import load_diabetes, load_boston # 引入糖尿病数据集与波士顿房价数据集from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_scoreimport pydotplus # 引入绘图模块from sklearn.externals.six import StringIOfrom sklearn.tree import export_graphviz# 引入回归数据集，并分为特征向量与标签向量reg_data = load_boston()# reg_data = load_diabetes()# print(reg_data.DESCR)X = reg_data.datay = reg_data.target# 分割数据集，其中80%用做训练，20%用做测试X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=1, test_size=0.2)# 训练决策回归树模型DTR = DecisionTreeRegressor(max_leaf_nodes=6) # 回归树的最大叶子数为6DTR.fit(X_train, y_train)y_predict = DTR.predict(X_test)# 模型可视化dot_data = StringIO() # 把文件暂时写在内存的对象中export_graphviz(DTR, out_file=dot_data, feature_names=reg_data.feature_names, filled=True, rounded=True, special_characters=True) # 利用export_graphviz模块导出回归树graph = pydotplus.graph_from_dot_data(dot_data.getvalue())graph.write_png('Boston.png')# 模型好坏评价print("回归树的拟合优度为：", r2_score(y_test, y_predict))print("预测结果的均方误差为： ", mean_squared_error(y_test, y_predict))print("预测结果的平均绝对误差为：", mean_absolute_error(y_test, y_predict))]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>回归决策树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next之主题优化]]></title>
    <url>%2F2018%2F10%2F10%2FOptimization-Ways-for-Next%2F</url>
    <content type="text"><![CDATA[实现功能通过上一篇博文的学习，我相信大家已经搭建出了功能相对完整的专属个人博客，但其实原生的next主题功能还是显得简陋了些，所以在这篇博文中我们就将学习如何在以下几个方面对next主题进行优化： 创建关于、标签、分类菜单项 添加本地搜索功能 添加头像 侧边栏设置社交链接 设置网站的图标Favicon 自定义代码块 浏览页面时显示当前进度 添加顶部加载条 添加网站访问量 隐藏底部的“Hexo强力驱动“字样 修改标签前的# 添加阅读全文 显示文章的字数与阅读时长 添加文章结束的显示字符 添加打赏功能 打开文章底部版权说明 添加文章分享链接 添加网站背景图片 图床的应用 编辑数学公式 在以上功能的实现过程中，我们需要对Hexo文件夹中的文件进行修改，由于config.yml配置文件存在两个，一个在根目录\Hexo\blog下，另一个在目录\Hexo\blog\themes\next下，为了进行区分，我们称前者为站点配置文件，后者为主题配置文件。同时，一定要注意的是修改_config.yml文件时冒号后面一定要有一个空格，否则生成代码时会报错。最后，根目录指的是路径\Hexo\blog，所有的插件安装命令都将在根目录下执行，下文将不再提醒。 具体步骤创建关于、标签、分类菜单项首先我们在主题配置文件的menu部分中开启关于、标签与分类菜单： 123456menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive 接下来我们利用命令行在\Hexo\blog\source目录下创建about、categories与tags这三个文件夹： 123hexo new page abouthexo new page categorieshexo new page tags 最后我们修改\Hexo\blog\scaffolds目录下的post文档（博文的模板）如下： 12345678---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;updated:tags: -categories:--- 添加本地搜索功能效果图： 实现方法：首先我们在根目录下安装本地搜索插件： 1npm install hexo-generator-searchdb --save 接着我们添加如下代码到站点配置文件的尾部： 12345search: path: search.xml field: post format: html limit: 10000 最后我们将主题配置文件的local_search设为true： 12local_search: enable: true 添加头像在主题配置文件中，我们放入头像图片的链接地址至avatar部分： 12345avatar: # in theme directory(source/images): /images/header.jpg # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. url: http://pgc23xl25.bkt.clouddn.com/blog/181009/a7I2C3k6JK.jpg?imageslim 在我的博客中，我是将图片存储在了七牛云的个人空间中（关于图床的使用我们会在后面介绍，以下所有我的图片链接都换成你自己的即可）；如果你的图片是存在本地的话，只需将地址修改为/images/头像图片名.jpg即可。 侧边栏设置社交链接在网站的侧边栏，我们可以添加一些我们的个人社交账号的链接，比如我就添加了自己的知乎、Github、Email与Twitter链接。在主题配置文件的social部分，我们可以修改如下： 123456social: 知乎: https://www.zhihu.com/people/ni-chen-23-96/activities || stack-overflow GitHub: https://github.com/Cyprus-hy || github E-Mail: mailto:heyuncc@163.com || envelope #Google: https://plus.google.com/yourname || google Twitter: https://twitter.com/Cyprus || twitter 设置网站的图标Favicon在网页的加载过程中，我们会在浏览器的标签页上看到一个小图标，那么我们可以通过对主题配置文件favicon部分的修改更换图标： 1234favicon: small: http://pgc23xl25.bkt.clouddn.com/blog/181009/a7I2C3k6JK.jpg?imageslim medium: http://pgc23xl25.bkt.clouddn.com/blog/181009/a7I2C3k6JK.jpg?imageslim apple_touch_icon: http://pgc23xl25.bkt.clouddn.com/blog/181009/a7I2C3k6JK.jpg?imageslim 自定义代码块在next主题中，默认的代码块是灰色的，有些难看，因此我们可以将其改成彩色的。在\Hexo\blog\themes\next\source\css\_custom目录下的custom.styl文件中添加如下代码： 123456789101112131415// Custom styles.code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 边框的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125; 浏览页面时显示当前进度在主题配置文件中，将scrollpercent部分改为true即可： 1scrollpercent: true 添加顶部加载条在主题配置文件中，将pace部分设置为true并选择一种加载样式即可： 123456789101112131415161718pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-minimal 添加网站访问量效果图： 实现方法：修改主题配置文件的busuanzi_count部分如下： 12345678busuanzi_count: enable: true total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye post_views: true post_views_icon: eye 隐藏底部的“Hexo强力驱动“字样在原生的next主题中，网站底部会有关于Hexo与NexT的一些版本链接信息，我们可以通过修改主题配置文件的copyright部分将其隐藏： 12345678910111213copyright:# -------------------------------------------------------------powered: # Hexo link (Powered by Hexo). enable: false # Version info of Hexo after Hexo link (vX.X.X). version: false theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: false # Version info of NexT after scheme info (vX.X.X). version: false 修改标签前的效果图： 实现方法：修改\Hexo\blog\themes\next\layout\_macro目录下的post.swig文件，搜索 rel=&quot;tag&quot;&gt;#，并将#替换为&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;。 添加阅读全文效果图： 实现方法：在markdown文章中要进行分割的段落前加上如下代码： 1&lt;!--more--&gt; 显示文章的字数与阅读时长效果图： 实现方法：首先在根目录下安装插件： 1npm install hexo-symbols-count-time --save 接着在站点配置文件的末尾加上如下代码： 123456# 阅读时间与文章字数symbols_count_time: symbols: true time: true total_symbols: true total_time: true 最后修改主题配置文件的symbols_count_time部分如下： 123456symbols_count_time: separated_meta: true item_text_post: true item_text_total: false awl: 2 wpm: 275 同时，你也可以参考官方文档。 添加文章结束的显示字符效果图： 实现方法：在目录\Hexo\blog\themes\next\layout\_macro下新建 passage-end-tag.swig 文件，并添加以下内容： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;---------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读---------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\Hexo\blog\themes\next\layout\_macro\post.swig文件，在post-body 之后， post-footer之前添加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 最后在站点配置文件的末尾添加如下代码： 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 添加打赏功能效果图： 实现方法:将主题配置文件的Reward部分修改如下： 1234# Rewardreward_comment: ----------此处弱弱求打赏*٩(๑´∀`๑)ง*----------wechatpay: http://pgc23xl25.bkt.clouddn.com/blog/181009/bGKK6F13Aa.jpg?imageslimalipay: http://pgc23xl25.bkt.clouddn.com/blog/181009/kA14bGK2H5.jpg?imageslim 其中wechatpay与alipay分别对应着你自己的微信与支付宝收款码。 打开文章底部版权说明效果图： 实现方法：将主题配置文件的post_copyright部分修改为true即可： 12post_copyright: enable: true 添加文章分享链接效果图： 实现方法：首先进入目录\Hexo\blog\themes\next下，并将相关库克隆至source/lib下： 1git clone https://github.com/theme-next/theme-next-needmoreshare2 source/lib/needsharebutton 接着根据自己的需要修改主题配置文件的needmoreshare2部分： 12345678enable: truepostbottom: enable: true options: iconStyle: box boxForm: horizontal position: bottomCenter networks: Wechat,QQZone,Weibo,Douban,Twitter 同时，你也可以参考官方文档。 添加网站背景图片在原生的next主题中，网站是没有背景图的，因此你可以根据自己的需要添加网页的背景图。在\Hexo\blog\themes\next\source\css\_custom目录下的custom.styl文件中添加如下代码： 1234567body&#123; background:url(http://pgc23xl25.bkt.clouddn.com/blog/181009/3KJ9gedamb.jpg?imageslim); background-size:cover; background-repeat:no-repeat; background-attachment:fixed; background-position:center;&#125; 图床的应用由于Github Pages的存储空间是有限的，因此我们可以考虑将我们的图片资源存储在七牛云的免费空间中。首先，我们需要在七牛云的官网注册一个账号（需要上传身份证进行审核）；接下来在对象存储中新建一个存储空间；然后再去官网下载一个图床神器MPic并设置自己的七牛云账号（Acesskey与Sceretkey可以在个人中心的密钥管理处查询）： 设置好账号后我们就可以拖拽图片到MPic图床处直接上传啦，当然你也可以设置MPic图床截图自动上传与复制图片自动上传，这样更方便！ 编辑数学公式有时候写博客免不了会涉及一些数学公式，但很遗憾hexo在默认情况下渲染数学公式是会出各种问题的，因此我在这里提供一种比较好的解决方案。 首先更换一下hexo的Markdown渲染引擎： 12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 再在站点配置文件下添加如下代码，进行引用： 12345678kramed: gfm: true pedantic: false sanitize: false tables: true breaks: true smartLists: true smartypants: true 同时修改E:\Hexo\blog\node_modules\kramed\lib\rules路径下的inline.js文件如下： 1234//escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/, escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,// em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, 接着在主题配置文件中将mathjax模块默认的false修改为true，最后需要编辑公式的时候再在文章的Front-matter部分进行引用即可，例如： 12345678---title: tags: -date: 2018-10-24 20:28:23updated:categories: mathjax: true--- 如果还有不清楚的地方，也可以参考官方文档。 结语对于next主题的优化，网上已经有很多教程，比如我就参考了这一篇和另一篇。但这些教程对应的next版本都比较老了，实际上目前很多功能已经被next收录了，所以你可以在主题配置文件中找到很多相关说明。同时对于每一部分的功能实现，配置文件中也给出了相应的参考网址，所以我建议你可以多读一读官方文档，这样往往会有事半功倍的效果。 最后，请开始你的博客之旅吧！٩(｡・▽・｡)ρ]]></content>
      <categories>
        <category>博客教程</category>
      </categories>
      <tags>
        <tag>next</tag>
        <tag>七牛云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客的简易教程]]></title>
    <url>%2F2018%2F10%2F05%2FTips-for-Building-Personal-Blog%2F</url>
    <content type="text"><![CDATA[写在前面其实很早就有搭建自己的专属博客的想法，一方面是希望用博客及时记录下自己在学习上的收获，方便复习；另一方面则是觉得自己似乎陷入了一种“快餐文化”，很多书、影视剧明明看过，但过不了两天就忘得一干二净了，真的就像那句话说的：I see that, but just see. 所以也希望自己能通过博客分享一些自己的人生感悟啥的，让自己变得勤于思考一些。 好了，接下来进入正题——如何让小白能在短时间内搭出一个让自己满意的博客，从零开始显然不是我们的风格，现在都8102年了，早已是开源的时代，网上有那么多好的框架我们当然得利用起来，所以本篇教程是以Github Pages为服务器支撑、Hexo的next主题背景为基础的，力求做到简单易上手。（PS：搭建我自己的博客我大概是用了一天多点，但其中大部分时间是花在了主题next的优化上，因为原生的next看起来会比较朴素，需要自己根据需要再往里面加功能，这个我会在下一篇博文中给出详细教程） 搭建个人博客 几点注意事项 1.以下所有关于npm install与hexo的命令行指令都是在hexo的blog目录下完成 2.配置文件_config.yml对格式要求很高，修改的时候注意每一个属性的冒号后有一个空格 3.我在GitHub中创建的个人博客仓库是以我的用户名命名的：Cyprus-hy.github.io，因此Cyprus-hy实际上对应着你自己的用户名 准备工作首先我们需要安装好Node.js、Git、Hexo这几个软件并提前在GitHub官网上注册好账号 安装Git直接去Git官网下载就好了，除了安装地址，其它设置都按默认的来，一直点next即可 安装Node.js一样地，也是去官网下载，然后一路next点到底 安装Hexo打开终端下的命令行界面，windows系统可以直接在左下角的搜索框中搜索cmd字样并回车，也可以用win+R的组合键再输入cmd打开，再在其中输入代码npm install -g hexo-cli，它就会自动帮你装好了，如下图： 注册Github账号事实上，每一个网站都有大量的资源文件需要进行存储，所以很多网站都会向提供商购买主机空间，但由于我们是个人博客，存储的资源并没有那么多，因此我们可以借用一下GitHub的免费网页服务，基本上也是够用的。注册账号的话上官网就好了（PS：我的界面是翻译后的，所以显示的是中文，相信英文界面你们也能看懂），记得用户名不要出现汉语。 配置本地博客首先在你的D盘或者E盘新建一个Hexo文件夹，然后再在Hexo文件夹上面的地址栏（也就是显示Hexo绝对路径的地方）里输入cmd，打开此目录下的命令行窗口，输入以下代码（所有的指令都是一行一行输入）： 1234hexo i blog //i是init的缩写 blog是项目名，代表在Hexo文件夹下再新建一个blog文件夹cd blog //切换到blog目录下hexo g //generetor的缩写，生成代码hexo s //server的缩写，部署在服务器上 正常情况下，每执行完一条语句就会有很多串代码，如果没有明显的fatal或failed等字样应该就没啥问题，同时我们在地址栏输入localhost:4000进行跳转查看，如果上面没啥问题的话，界面应该是这样的（盗用了一张别人的图，侵删）： 更改主题相信你也发现了，Hexo自带的原生主题其实是蛮丑的，所以我们可以换一个好看一些的主题。关于主题，GitHub上有很多资源包，我比较喜欢的是yilla与next。首先我们用cd themes命令进入到themes文件夹下，再将主题包从Github上克隆下来： yilia: 1git clone https://github.com/litten/hexo-theme-yilia.git next: 1git clone https://github.com/theme-next/hexo-theme-next themes/next 由于我自己使用的是next主题，所以我接下来的一系列设置都针对的是next，如果您喜欢的是yilia或者其它主题，可以另外寻找一下教程。 这时我们会发现在blog的themes目录下已经出现了一个next文件夹，而这就是我们的主题包。接下来我们介绍配置文件_config.yml，实际上它有两个，一个在blog目录下，称为站点配置文件；而另一个在next文件夹下，称为主题配置文件，这两个文件很重要，修改的时候一定要注意是改哪一个！ 此外，next下还细分了四种主题：Muse、Mist、Pisces与Gemini，默认的是Muse，不过我觉得Pisces和Gemini更好看（我用的是Gemini，不过我发现Pisces和Gemini一样的啊），可以自己在主题配置文件中改一改看一看： 每次修改完后，我们都需要重新生成代码并部署到本地服务器上进行更新： 123hexo clean //清除之前生成的代码hexo g //重新生成代码hexo s //部署到本地服务器 最后跳转到localhost:4000网页进行查看next的主题效果。 配置Github PagesGithub有专为网页服务的个人仓库，因此我们首先创建一个个人仓库，点击个人主页的右上角Create a repositor ，进入如下页面： 这里需要注意的是仓库的名字格式必须为Cyprus-hy.github.io（Cyprus-hy对应你自己的用户名，因为我的同名仓库已经存在，所以无法创建），然后其它的部分可以仿照我的进行勾选。接下来我们再更改仓库的设置，点击如下图的设置： 下拉到Github Pages选项，并点击choose a theme： 注意，我这里的网址是已经进行了域名解析了的,正常情况下最上方出现的应是Your site is published at http://www.Cyprus-hy.github.io/，其中Cyprus-hy对应你自己的用户名。 然后在如下界面中随便选择一个主题进行应用，当然最终这个会被next替换的： 主题应用完之后，我们可以在地址栏输入用户名.github.io进行跳转访问，这时你就能看到Github给你提供的免费个人博客网页啦，接下来我们要做的就是把自己的网页主题更改成next。 配置SSH首先执行下面的命令生成SSH： 1ssh-keygen 按三次回车，即可生成id_rsa.pub文件，如果你的电脑装有vim编译器，你可以用指令vim ~/.ssh/id_rsa.pub查看文件中的内容并进行复制；如果你没有vim，你可以使用搜索软件搜索到本地的id_rsa.pub文件再打开查看（搜索软件推荐everything，查看编辑软件推荐sublime text）。复制文件中的所有内容，并在Github的个人主页中点击设置，再在左侧的个人设置中点击选项SSH和GPG keys，然后点击右侧的New SSH key，出现如下界面： 此时我们需要把从id_rsa.pub文件中复制的内容粘贴到下面的key框中，其中title可以随意填写，再点击Add SSH key即可。 同时，为了验证SSH是否已经配置好，我们可以输入如下指令： 1ssh -T git@github.com 如果出现了类似的如下信息，即代表配置成功： 1Hi Cyprus-hy! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 配置本地Hexo首先我们打开站点配置文件，仿照我的格式对Deployment部分做如下修改： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/Cyprus-hy/Cyprus-hy.github.io.git branch: master 注意仓库内填入你自己的用户名以及切记冒号后的空格！！！ 接下来我们安装一个插件，它可以将你在本地Hexo文件夹中的修改自动同步到Github的个人博客仓库中： 1npm install hexo-deployer-git --save 然后重新生成代码并部署到GitHub的服务器上（注意掌握这三句指令，任何修改都需要在服务器上重新部署）： 123hexo cleanhexo ghexo d //部署指令，注意这里是d而不是s 最后我们再次访问地址用户名.github.io就会发现你的博客页面已经变成next主题啦。 对于搭建个人博客的过程，我参考了这个与另一个博客，特此感谢。 域名解析尽管Github向我们提供了一个免费的域名：用户名.github.io，但这个域名用起来还是挺不方便的，因为它的访问速度比较慢，而且你在本地的修改部署到服务器上后会有比较大的延迟，经常要刷新好几次或者等好一会儿才会看到更新。所以我还是推荐花几十块钱买个一年的域名，在网上搜了一圈发现推荐的基本都是国外的Godaddy与阿里云的万网，因为它两服务都还可以、价格还算实惠以及不用备案。我自己选择的是Godaddy，服务还行，但是我一定要吐槽的一点就是它们发邮件的速度太慢了，要过很久才能收到，尤其是QQ邮箱。由于Godaddy自己的域名解析比较慢，所以我用了DNSPod进行解析，并将Godaddy自己的域名服务器修改为DNSPod的域名地址。 购买域名上Godaddy官网买就好了，选一个自己喜欢的域名，一般.com和.net后缀的会比较贵，个人博客的话完全可以买.ifo与.co这样便宜的，还有就是Godaddy的附加服务可以都不选，没啥用。 DNSPod设置域名首先进入DNSPod官网，点击中间的添加域名把你刚刚买好的域名添加进行，然后点击域名进行添加记录。在这里我们需要添加两条记录，一条CNAME记录用于指向域名，多用于带www的访问；一条A记录用于指向域名对应的IP，多用于不带www的访问。以我自己的博客Cyprus-hy.github.io为例，我们首先ping一下它的IP： 1ping Cyprus-hy.github.io 接着我们开始添加这两条记录，如下图的第一条与第四条记录，而第二、三条记录是DNSPod自动生成的，这个会在Godaddy自己的域名服务器上用到： 添加CNAME文件同时，我们需要在个人博客仓库中添加CNAME文件，在Cyprus-hy.github.io仓库中点击右上角的Create new file，文件名为CNAME，文件内容为www.heyun.life，即对应你自己购买的域名。 然后我们可以通过Download的方式下载下整个仓库并将CNAME文件放到Hexo\blog\source处。当然，你可以先在本地创建CNAME文件再同步到Github上，但需要注意CNAME文件是没有后缀名的。 Godaddy配置由于Godaddy才是我们域名的管理商，而我们又希望通过DNSPod进行域名解析，因此我们需要将Godady的域名服务器指定为DNSPod的域名地址。这里需要插一句，在购买完域名后，Godaddy会发送邮件进行邮箱认证，如果你注册用的是QQ邮箱，接收到邮件的时间要很久，网易的163邮箱与Gmail会好一些，但也要一段时间，所以耐心等待就好，因为没有验证邮箱的话是无法进行接下来的操作的。 首先，我们依次点击我的产品-&gt;DNS，如下图： 接着我们下拉界面至域名服务器，点击更改进行自定义配置： 上图是我已经配置好的域名服务器，这里我再给出一下DNSPod的域名地址： 12f1g1ns1.dnspod.netf1g1ns2.dnspod.net 由于域名解析生效需要一段时间（大概20分钟），所以我们只需要等待一段时间便可以在浏览器的地址栏输入自己的博客域名进行访问啦。 对于域名解析的步骤，我参考了这位作者的博客，特此感谢。 结语到这里，我们已经完成了个人博客的搭建，怎么样，看着自己的博客可以被浏览器访问是不是成就感爆棚呢？哈哈哈。不过别着急，细心的你应该发现了：原生的next主题的功能是不完善的，比如没有搜索、分类等功能，也没有个人头像等信息，而在下一个教程中，我就将带领大家对next主题进行优化。]]></content>
      <categories>
        <category>博客教程</category>
      </categories>
      <tags>
        <tag>next</tag>
        <tag>Github Pages</tag>
        <tag>Hexo</tag>
        <tag>DNSPod</tag>
      </tags>
  </entry>
</search>
